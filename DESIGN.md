## Paperback Design ##

The following is a description of the design behind paperback.

### Overview ###

Paperback is designed to store a person's secret data in a manner such that
they can be recovered with a quorum of people coming together for the recovery.

It is a necessary part of this model that this recovery can occur without the
original person present, as one use-case of paperback is to act as a person's
will. If this is not what the person wants, they should encrypt their document
with a secret passphrase before providing it to paperback.

There are two primary documents in paperback, both of which are required in
order to facilitate a recovery event:

 1. The "main document" stores an encrypted copy of the person's secret data.
    It is up to the user whether they wish to only have one copy of this
    document, or many.

 2. "Key shards" are individual documents which store a portion of the secret
    key used to encrypt the "main document" (in a zero-information manner). A
    unique "key shard" is provided to each person who can form the quorum.

For the purpose of this document, the set of people who possess a "key shard"
are called "key-holders". When N people come together to perform a recovery
event, that group is called a "quorum" (with each member being called a "quorum
member").

### Threat Model ###

We assume that all of the cryptographic primitives used are computationally
hard to break, and are thus trustworthy enough for our use. However, if the
cryptographic primitives used in this design are found to be compromised, we
can migrate to newer ones.

We also assume that the original user made an accurate decision about the
quorum size (that no more than N-1 people will either be compromised or
collaborate to attack the secret data). However, paperback must be secure even
with up to N-1 malicious quorum members.

We assume that the quorum is using a real copy of paperback, as otherwise we
cannot guarantee that the software they use will not produce a fake result. And
while it may be possible to prove that the result is fake using the real
paperback software, that presupposes that they have access to the real
paperback.

Therefore, paperback must be able to detect if malicious quorum members have
produced fake key shards or fake documents. It must not allow fewer than N
people to recover the secret. It also should protect against N people creating
a fake document that other key-holders then cannot detect is a fake document.

### Design ###

The main cryptographic primitives used in this design are:

 * `CSPRNG(n)` generates `n` bytes of cryptographically-random data.

 * `AEAD_GenKey()` generates a random and secure cryptographic key, usable for
   `AEAD_Enc` and `AEAD_Dec`.
 * `AEAD_Enc(K, nonce, plain, ad)` symmetrically encrypts the plain-text
   `plain` with associated data `ad` with key `K` and nonce `nonce`.
 * `AEAD_Dec(K, nonce, cipher, ad)` symmetrically decrypts the cipher-text
   `cipher` with associated data `ad` with key `K` and nonce `nonce`.

 * `Hash(data)` produces a cryptographic hash of `data`.

 * `Sig_GenPrivKey()` generates a random and secure cryptographic key, usable
   for `Sig_Sign` and `Sig_Verify`.
 * `Sig_GetPubKey(K_priv)` calculates the corresponding public key for the
   private key `K_priv` generated by `Sig_GenPrivKey`.
 * `Sig_Sign(K_priv, data)` signs the bytes `data` using the private key
   `K_priv`.
 * `Sig_Verify(K_pub, data, sig)` verifies that the signature `sig` by the
   public key `K_pub` of the bytes `data` is valid.

 * `Secret_Share(secret, n, k)` generates `k` shards of the secret data
   `secret`, such that `n` quorum members are required to reconstruct the
   secret.
 * `Secret_Recover(shards, n)` recovers the secret sharded into the given
   `shards` with quorum size `n`.
 * `Secret_Expand(shards, n, k2)` generates an additional `k2` shards by
   recovering the necessary information from `shards` with quorum size `n`.
   These shards should be statistically improbable to coincide with any other
   shards previously generated.

`AEAD_Enc` and `AEAD_Dec` are implemented using the AEAD construction of
`ChaCha20-Poly1350` as defined in RFC 8439. `Hash` is `BLAKE2b`.
`Sig_GetPubKey`, `Sig_Sign`, and `Sig_Verify` are implemented using `Ed25519`.
`Secret_Share`, `Secret_Recover`, and `Secret_Expand` are implemented using
Shamir Secret Sharing.

`AEAD_GenKey` and `Sig_GenPrivKey` are both implemented using the
relevant secure randomness source provided by the operating system. This is
permitted because `ChaCha20-Poly1305` and `Ed25519` both permit arbitrary
random values as private keys. If the algorithm choice is modified in the
future, this assumption will need to be reconsidered.

`Rand` is also implemented using the relevant secure randomness source provided
by the operating system, but this is not required for the security of
paperback.

#### Creation ####

Let `secret` be the secret data which the user wants to store. Let `n` be the
size of the quorum the user selected, and `k` be the number of key shards to be
created (assuming `k > n`).

We first generate all of the necessary keys and shards:

```
K_doc = AEAD_GenKey()

K_id_priv = Sig_GenPrivKey()
K_id_pub = Sig_GetPubKey(K_id_priv)

K_shards = Secret_Share(K_doc || K_id_priv, n, k)
```

Then the main document is formed (treat it as a JSON object):

```
doc_id = CSPRNG(6) // secure randomness not required
doc_nonce = CSPRNG(NONCE_SIZE)

Doc[meta] = doc_id || n
Doc[body] = doc_nonce || AEAD_Enc(K_doc, doc_nonce, secret, Doc[meta] || K_id_pub)
Doc[id_pub] = K_id_pub
Doc[id_sig] = Sig_Sign(K_id_priv, Doc[meta] || Doc[body] || Doc[id_pub])
Doc[chksum] = Hash(Doc[meta] || Doc[body] || Doc[id_pub] || Doc[id_sig])
```

Then the key shards are formed (treat them as JSON objects). For each `K_shard`
in `K_shards`:

```
K_shard = AEAD_GenKey()

shard_id = CSPRNG(6) // secure randomness not required
shard_nonce = CSPRNG(NONCE_SIZE)

Shard[meta] = doc_id || shard_id || Doc[chksum]
Shard[body] = shard_nonce || AEAD_Enc(K_shard, shard_nonce, n || K_shard, Shard[meta] || K_id_pub)
Shard[id_pub] = K_id_pub
Shard[id_sig] = Sig_Sign(K_id_priv, Shard[meta] || Shard[body] || Shard[id_pub])
Shard[shard_chksum] = Hash(Shard[meta] || Shard[body] || Shard[id_pub] || Shard[id_sig])

// The key is included, to allow for users to optionally store the key
// separately (or keep it with the main document to make this level of security
// a no-op).
Shard[key] = K_shard
```

#### Recovery ####

During recovery, we may discover that the document or one or more key shards do
not have consistent values for `K_id_pub` or `Doc[chksum]`. This indicates that
at least one of the documents has been forged, but it is not possible to be
sure which documents have been forged. However it is possible to display to
users (possibly graphically) which documents are consistent with each other,
and thus perhaps allow for a social solution to the conflict. In all such
cases, the recovery operation must abort.

When recovering, first the main document is verified:

```
// Ensure the checksum and signature are valid.
if Doc[chksum] != Hash(Doc[meta] || Doc[body] || Doc[id_pub] || Doc[id_sig])
	abort "Main document checksum mismatch -- bad data."
if not Sig_Verify(Doc[id_pub], Doc[meta] || Doc[body] || Doc[id_pub], Doc[id_sig])
	abort "Main document signature mismatch -- forgery detected"

{doc_doc_id, doc_n} = Doc[meta]
```

Then each of the shards are verified. For each `Shard` in the given set:

```
// Ensure the checksum and signature are valid.
if Shard[chksum] != Hash(Shard[meta] || Shard[body] || Shard[id_pub] || Shard[id_sig])
	abort "Shard checksum mismatch -- bad data."
if not Sig_Verify(Shard[id_pub], Shard[meta] || Shard[body] || Shard[id_pub], Shard[id_sig])
	abort "Shard signature mismatch -- forgery detected."

{shard_doc_id, shard_id, shard_doc_chksum} = Shard[meta]
{shard_n, shard} = Shard[body]

// All shards and documents must use the same public identity keys.
if Shard[id_pub] != Doc[id_pub]
	abort "Inconsistent identities -- forgery detected."

// The shard must agree on the document's checksum.
if shard_doc_chksum != Doc[chksum]
	abort "Document checksum doesn't match shard's copy -- forgery detected."

// All shards and documents must agree on basic metadata.
if shard_doc_id != doc_doc_id || shard_n != doc_n
	abort "Inconsistent metadata -- forgery detected."

// All shards must have a unique shard_id.
if shard_id == any other shard_id
	abort "Duplicate or fake duplicate shard -- possible forgery detected."

// Decrypt the shard.
{shard_nonce, shard_ciphertext} = Shard[body]
shard, error = AEAD_Dec(Shard[key], shard_nonce, shard_ciphertext, Shard[meta] || Shard[id_pub])
if error
	abort "Error encountered during decryption -- possible forgery detected."

// All good!
shards.append(shard)
```

Once all the shards have been verified against the document, and no errors have
been found, the recovery process can be completed:

```
// Get the secret data.
{K_doc, K_id_priv}, error = Secret_Recover(shards, doc_n)
if error
	abort "Error encountered during secret recovery."

// Make sure that that K_id_priv matches. At this point, we've already revealed
// the secrets but it doesn't hurt to double-check.
if Sig_GetPubKey(K_id_priv) != Doc[id_pub]
	abort "Inconsistent identities -- forgery detected."

// Decrypt the main document.
{doc_nonce, doc_ciphertext} = Doc[body]
secret, error = AEAD_Dec(K_doc, doc_nonce, doc_ciphertext, Doc[meta] || Doc[id_pub])
if error
	abort "Error encountered during decryption -- possible forgery detected."
```

#### Expansion ####

Let `k2` be the additional number of shards needed.

In certain circumstances, it is necessary to able to create new shards.
However, the most trivial way (creating a new paperback backup) means that any
old shares become invalidated. This is problematic because some key-holders may
not be easily reachable to replace their existing key shard.

Thus, paperback supports creating new key shards which are compatible (but
distinct) from any others. In order to perform this operation a quorum is
required, but the main document is not necessary. Note that this operation
allows the quorum to produce a virtually unlimited number of key shards, and
that this feature is an unavoidable mathematical feature of the construction of
Shamir Secret Sharing.

The process for verifying the shards is very similar to the recovery scenario,
except that the shard metadata is compared with other shards rather than
against the main document. The same caveat about forgery detection applies here
too. For each `Shard` in the given set:

```
// Ensure the checksum and signature are valid.
if Shard[chksum] != Hash(Shard[meta] || Shard[body] || Shard[id_pub] || Shard[id_sig])
	abort "Shard checksum mismatch -- bad data."
if not Sig_Verify(Shard[id_pub], Shard[meta] || Shard[body] || Shard[id_pub], Shard[id_sig])
	abort "Shard signature mismatch -- forgery detected."

{shard_doc_id, shard_id, shard_doc_chksum} = Shard[meta]
{shard_n, shard} = Shard[body]

// All shards and documents must use the same public identity keys.
if Shard[id_pub] != any other Shard[id_pub]
	abort "Inconsistent identities -- forgery detected."

// The shard must agree on the document's checksum.
if shard_doc_chksum != any other shard_doc_chksum
	abort "Document checksum doesn't match shard's copy -- forgery detected."

// All shards and documents must agree on basic metadata.
if shard_doc_id != any other shard_doc_id || shard_n != any other shard_n
	abort "Inconsistent metadata -- forgery detected."

// All shards must have a unique shard_id.
if shard_id == any other shard_id
	abort "Duplicate or fake duplicate shard -- possible forgery detected."

// Decrypt the shard.
{shard_nonce, shard_ciphertext} = Shard[body]
shard, error = AEAD_Dec(Shard[key], shard_nonce, shard_ciphertext, Shard[meta] || Shard[id_pub])
if error
	abort "Error encountered during decryption -- possible forgery detected."

// All good!
shards.append(shard)
```

Once all the shards have been verified against the document, and no errors have
been found, the recovery process can be completed:

```
// Get the secret data.
{K_doc, K_id_priv}, error = Secret_Recover(shards, doc_n)
if error
	abort "Error encountered during secret recovery."

// Make sure that that K_id_priv matches. At this point, we've already revealed
// the secrets but it doesn't hurt to double-check.
if Sig_GetPubKey(K_id_priv) != Doc[id_pub]
	abort "Inconsistent identities -- forgery detected."

// Decrypt the main document.
{doc_nonce, doc_ciphertext} = Doc[body]
secret, error = AEAD_Dec(K_doc, doc_nonce, doc_ciphertext, Doc[meta] || Doc[id_pub])
if error
	abort "Error encountered during decryption -- possible forgery detected."
```

Once all the shards have been verified against each other, and no errors have
been found, the expansion process can be completed. Let `n` be the consistent
`shard_n` value.

```
{K_doc, K_id_priv} = Secret_Recover(shards, n)
new_K_shards = Secret_Expand(shards, n, k2)
```

The new key shards are constructed as during creation. Let `doc_id` and
`doc_chksum` be the consistent `shard_doc_id` and `shard_doc_chksum`
values, respectively. For each `K_shard` in `new_K_shards`:

```
K_shard = AEAD_GenKey()

shard_id = CSPRNG(6) // secure randomness not required
shard_nonce = CSPRNG(NONCE_SIZE)

Shard[meta] = doc_id || shard_id || doc_chksum
Shard[body] = shard_nonce || AEAD_Enc(K_shard, shard_nonce, n || K_shard, Shard[meta] || K_id_pub)
Shard[id_pub] = K_id_pub
Shard[id_sig] = Sig_Sign(K_id_priv, Shard[meta] || Shard[body] || Shard[id_pub])
Shard[shard_chksum] = Hash(Shard[meta] || Shard[body] || Shard[id_pub] || Shard[id_sig])

// The key is included, to allow for users to optionally store the key
// separately (or keep it with the main document to make this level of security
// a no-op).
Shard[key] = K_shard
```
